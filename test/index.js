'use strict';

// Imports

const Lab = require('lab');
const Code = require('code');
const Sinon = require('sinon');
const Sut = require('../');

// Test shortcuts

const lab = module.exports.lab = Lab.script();
const describe = lab.describe;
const it = lab.it;
const beforeEach = lab.beforeEach;
const expect = Code.expect;


describe('better-map', () => {

    let test;

    beforeEach((done) => {

        test = new Sut([
            ['one', 1],
            ['two', 2]
        ]);

        return done();
    });

    describe('constructor', () => {

        it('should create a map without entries when called without an iterator', (done) => {

            // Act
            const myMap = new Sut();

            // Assert
            expect(myMap.size).to.equal(0);

            return done();
        });

        it('should create a map with entries when called with a valid iterator', (done) => {

            // Act
            const myOtherMap = new Sut([
                ['one', 1],
                ['two', 2]
            ]);

            // Assert
            expect(myOtherMap.size).to.equal(2);

            return done();
        });
    });

    describe('entriesArray', () => {

        it('should return an array of key and value as an array in the order they were added into the map', (done) => {

            // Act
            const actual = test.entriesArray();

            // Assert
            expect(actual).to.equal([['one', 1], ['two', 2]]);

            return done();
        });
    });

    describe('keysArray', () => {

        it('should return the keys as an array in the order they were added into the map', (done) => {

            // Act
            const actual = test.keysArray();

            // Assert
            expect(actual).to.equal(['one', 'two']);

            return done();
        });
    });

    describe('valuesArray', () => {

        it('should return the values as an array in the order they were added into the map', (done) => {

            // Act
            const actual = test.valuesArray();

            // Assert
            expect(actual).to.equal([1, 2]);

            return done();
        });
    });

    describe('map', () => {

        it('should call the callback with the expected parameters', (done) => {

            // Arrange
            const mapper = Sinon.stub().returns(0);

            // Act
            const actual = test.map(mapper);

            // Assert
            expect(actual).to.equal([0, 0]);
            Sinon.assert.calledTwice(mapper);
            Sinon.assert.calledWithExactly(mapper, 1, 'one', test);
            Sinon.assert.calledWithExactly(mapper, 2, 'two', test);

            return done();
        });

        it('should call the callback with the expected parameters including thisArg', (done) => {

            // Arrange
            const mapper = Sinon.stub().returns(0);
            const thisArg = { a: 'a' };

            // Act
            const actual = test.map(mapper, thisArg);

            // Assert
            expect(actual).to.equal([0, 0]);
            Sinon.assert.calledTwice(mapper);
            Sinon.assert.calledWithExactly(mapper, 1, 'one', test);
            Sinon.assert.calledWithExactly(mapper, 2, 'two', test);
            expect(mapper.thisValues[0]).to.shallow.equal(thisArg);
            expect(mapper.thisValues[1]).to.shallow.equal(thisArg);

            return done();
        });

        it('should return an array of values generated by the callback function', (done) => {

            // Act
            const actual = test.map((value, key) => `${key} = ${value}`);

            // Assert
            expect(actual).to.equal(['one = 1', 'two = 2']);

            return done();
        });
    });

    describe('reduce', () => {

        it('should call the callback with the expected parameters when called without initial', (done) => {

            // Arrange
            const reducer = Sinon.stub().returns(0);

            // Act
            const actual = test.reduce(reducer);

            // Assert
            expect(actual).to.equal(0);
            Sinon.assert.calledTwice(reducer);
            Sinon.assert.calledWithExactly(reducer, undefined, 1, 'one', test);
            Sinon.assert.calledWithExactly(reducer, 0, 2, 'two', test);

            return done();
        });

        it('should call the callback with the expected parameters when called with initial', (done) => {

            // Arrange
            const reducer = Sinon.stub().returns(0);

            // Act
            const actual = test.reduce(reducer, 1337);

            // Assert
            expect(actual).to.equal(0);
            Sinon.assert.calledTwice(reducer);
            Sinon.assert.calledWithExactly(reducer, 1337, 1, 'one', test);
            Sinon.assert.calledWithExactly(reducer, 0, 2, 'two', test);

            return done();
        });

        it('should return an array of values generated by the callback function', (done) => {

            // Act
            const actual = test.reduce((pv, cv) => pv + cv, 0);

            // Assert
            expect(actual).to.equal(3);

            return done();
        });
    });

    describe('some', () => {

        it('should be a function', (done) => {

            // Assert
            expect(test.some).to.exist().and.be.a.function();

            return done();
        });

        it('should return true if at least one callback returns true', (done) => {

            // Arrange
            const callback = Sinon.stub().returns(true);

            // Act
            const actual = test.some(callback);

            // Assert
            expect(actual).to.be.true();
            Sinon.assert.calledOnce(callback);

            return done();
        });

        it('callback should be called with thisArg as the context, this', (done) => {

            // Arrange
            const callback = Sinon.stub().returns(true);
            const thisArg = { a: 'a' };

            // Act
            test.some(callback, thisArg);

            // Assert
            Sinon.assert.calledOnce(callback);
            expect(callback.thisValues[0]).to.shallow.equal(thisArg);

            return done();
        });

        it('should return false no callbacks return true', (done) => {

            // Arrange
            const callback = Sinon.stub().returns(false);

            // Act
            const actual = test.some(callback);

            // Assert
            expect(actual).to.be.false();
            Sinon.assert.calledTwice(callback);

            return done();
        });
    });
});
